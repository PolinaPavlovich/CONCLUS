---
title: "CONCLUS: from CONsensus CLUSters to a meaningful CONCLUSion"
header-includes: \usepackage{graphicx}
author: | 
  | Polina Pavlovich$^1$$^2$$^3$
  |
  | $^1$European Molecular Biology Laboratory, EMBL, Rome, Italy
  | $^2$Moscow Institute of Physics and Technology, MIPT,  Moscow, Russia
  | $^3$Max Planck Institute of Immunobiology and Epigenetics, MPI-IE, Freiburg, Germany (current)
output:
  html_notebook:
    css: custom.css
    toc: true # table of content true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    theme: cerulean
---
# Introduction

CONCLUS is a tool for robust clustering and positive marker features selection. It was developed for single-cell RNA-seq (scRNA-seq) data but can be potentially applied to any tab-delimited matrix where columns are samples, rows are features, and at the intersection is the number of feature elements in the column. CONCLUS takes advantage of the fact that scRNA-seq allows you to sequence an extensive array of cells and we recommend to apply this tool if you have at least 100 columns. This vignette demonstrates the functionality of CONCLUS on a scRNA-seq dataset from the [*Bergiers et al. eLife 2018*](https://elifesciences.org/articles/29312) article. Designs for scRNA-seq experiments authors described in *Figure 4—figure supplement 2* of the original article. Authors wanted to analyze the effect of the simultaneous expression of eight transcription factors (8TFs) *Runx1* and its partner *Cbfb*, *Gata2*, *Tal1*, *Fli1*, *Lyl1*, *Erg* and *Lmo2* in comparison to ‘empty’ untreated embryonic stem cells (ESCs). They knocked-in a polycistronic genetic construct containing the coding sequences of the 8TFs separated by T2A cleavage site (allowing skipping of the ribosome during translation) into the HPRT locus downstream of doxycycline (dox) inducible promoter. The treatment with dox would lead to the over-expression of the transgene. Dox- cells were expected to be similar to ‘empty’ cells. This dataset is a challenging example of studying subpopulations within one cell type. We will see if CONCLUS manages to distinguish treated by inducing 8TFs (i8TFs) and activated by dox cells from control groups. Even more, it will be interesting if the algorithm will characterize substructure within those groups which were not captured by PCA ([*Figure 4—figure supplement 2*](https://elifesciences.org/articles/29312/figures#fig4s2)).

# Getting started with CONCLUS
All code from this vignette is an extended version of *Example_full_workflow.R* (link to the script). We recommend using that script as a template for your daily analysis when the vignette contains extensive and detailed information about the CONCLUS algorithm and can be used for informational purposes. The R version which we use is 3.4.3.

These are the early days of CONCLUS, and it exists not yet as a package but as a script *visualisation_and_clustering_functions.R* which you can download from the GitHub folder https://github.com/PolinaPavlovich/CONCLUS. To run it on your machine you may need to install required packages if your R folder does not have them yet — all packages that CONCLUS needs are listed in the R chunk below. Please remove the first commenting symbol "#" in each line. Once you run it, you can skip this step next time.

```{r}
# install all needed packages 
# #cran
# install.packages(c("ggplot2", "Matrix", "dbscan", "pheatmap", "fpc", "zoo",
#"dynamicTreeCut", "factoextra", "digest", "RColorBrewer", "doParallel", 
#"dplyr", "matrixStats"))
# #bioconductor
# source("https://bioconductor.org/biocLite.R")
# biocLite(c("BiocParallel", "scran", "scater", "monocle", 
#"KEGGREST", "org.Mm.eg.db", "biomaRt", "AnnotationDbi"))
# biocLite("SingleCellExperiment", dependencies=TRUE, lib="~/R/library")
```

# Reading the example data into R and preparing it for the analysis
Firstly, we specify our working directory where we want to store all input and output files. Most of the CONCLUS functions save plots and tables directly into your working directory. However, you can also ask to return a picture to an object. Every output file will start with *experimentName*. We call our experiment "Bergiers" as the surname of the first author of the selected paper.
```{r}
# setting necessary parameters
# ! Please, select an existing directory where you want to store output files
dataDirectory <- "/g/lancrin/People/Pauline/data/CONCLUS_vignette"
experimentName <- "Bergiers"
```

## Downloading the count matrix
We use a publicly available dataset which allows us to download the count matrix from Gene Expression Omnibus database by the accession number [*GSE96982*](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE96982). We save it to our *dataDirectory* and call it *GSE96982_countMatrix.txt*. Since we download an archive, we gunzip using command line wrapper in R.
```{r}
filename <- file.path(dataDirectory, "GSE96982_countMatrix.txt")
download.file("https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE96982&format=file&file=GSE96982%5FcountMatrix%2Etxt%2Egz",
              destfile = paste0(filename, ".gz"))
system(paste0("gunzip ", paste0(filename, ".gz")))
```

## Reading count matrix and metadata table into R
At this step, we are ready to upload the count matrix with raw UMIs into our Rstudio. We also need the metadata table provided by the authors. It is slightly more challenging to download it from R so that you can download the metadata file "sample.tsv" either from our folder or from [here](https://www.ncbi.nlm.nih.gov/geo/browse/?view=samples&series=96982) and by clicking on Export -> Amount: All search results and Format: Tab. Please move it to your *dataDirectory*.
```{r}
countMatrix <- read.delim(filename, stringsAsFactors = FALSE)
rm(filename)
colData <- read.delim(file.path(dataDirectory, "sample.tsv"))
```

## Preparing the data for CONCLUS
The first column in the *countMatrix* contains gene names; we use it as row names and delete it because we want all columns to be numeric. The column *Title* in the *colData* contains two kinds of information: state (condition) and cell barcode (cell name). We separate them and save in two different columns. 
```{r}
rownames(countMatrix) <- countMatrix[,1]
countMatrix <- countMatrix[,-1]

colData$state <- gsub(":.*", "", colData$Title)
colData$cellBarcode <- gsub(".*:", "", colData$Title)
```

Cell barcodes are not convenient to handle, so we rename the cells with simple labels as *c1*, *c2*, etc. We save this info into colData and check that the order of cells in *colData* is the same as in the *countMatrix*. Coldata from the website contains a lot of information but to use CONCLUS; we will need only the 13th, 14th, and 15th columns: *state*, *cellBarcode*, and *cellName*.

```{r}
# replacing cellBarcodes with c1, c2 because it is easier to work with
colData$cellName <- paste0("c", 1:nrow(colData))
rownames(colData) <- colData$cellName
countMatrix <- countMatrix[,colData$cellBarcode]
stopifnot(all(colData$cellBarcode == colnames(countMatrix)))

colnames(countMatrix) <- colData$cellName

colData <- colData[,13:15]
```

*CountMatrix* includes cells from the following states: *i8TF_plus* corresponds to cells expressing the 8TFs construct following dox treatment (induced 8TFs plus dox); *i8TFs_minus* were cells not treated with dox and therefore not expressing the 8TFs construct; *E_plus* ('E' from 'Empty') -- cells without transgene but treated with dox; while *E_minus* were control ES cells not treated with dox. The cells from each condition were produced following ESC differentiation into the blood and endothelial cells. Additionally, there were four *Neg_Ctrl*, four *Pos_Ctrl*, and 15 *K562* cells which we do not want to include in the clustering analysis, so we explicitly select only the first four conditions.

```{r}
# deleting controls
colData <- colData[grepl("E_minus", colData$state) |
                      grepl("E_plus", colData$state) |
                      grepl("i8TFs_minus", colData$state) |
                      grepl("i8TFs_plus", colData$state),]
countMatrix <- countMatrix[,colData$cellName]
```

### Removing the induced 8 TFs from the expression matrix
To avoid a bias in the clustering analysis due to the high expression of the eight transcription factors construct, we decided to delete those eight genes before the downstream analysis. The countMatrix contains genes in ENSEMBL annotation; we combined them with symbols into a table “8TFs_ENSEMBL_SYMBOL.txt” which you can download from the same folder as the vignette.

```{r}
eigthTF <- read.delim(file.path(dataDirectory, "8TFs_ENSEMBL_SYMBOL.txt"),
                      stringsAsFactors = FALSE)
library(knitr)
kable(eigthTF, caption = "Eigth transcription factors included into the construct, inserted into ESCs genome and activated by doxycycline.", format = 'pandoc')
```

```{r}
dim(countMatrix)
countMatrix <- countMatrix[!(rownames(countMatrix) %in% eigthTF$ENSEMBL),]
dim(countMatrix)
```

# CONCLUS workflow
## Loading functions
We source all CONCLUS functions from the script *visualisation_and_clustering_functions.R*.
```{r}
# setting seed for reproducibility
set.seed(42)
# loading functions
# ! Please, enter the path to visualisation_and_clustering_functions.R which
# you downloaded from GitHub
source("/g/lancrin/People/Pauline/data/CONCLUS_vignette/visualisation_and_clustering_functions.R")
```

## Genes and cells filtering, normalization
CONCLUS offers two methods of normalization: "default" and "census." Both of them have their genes and cells filtering steps followed by normalization. The “default” normalization procedure is done using Scran and Scater packages. The “census” normalization was described in the paper of [*Qiu X et al. Nat Methods 2017*](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5330805/), and the full function including cell quality controls and filtering steps was kindly provided by Ph.D. student Alexey Samosyuk from SkolTech Institute. In this vignette, we will you the "default" method of normalization. In the first step, it will annotate genes using the biomaRt database and add statistics about cells into *colData*. If you already have *colData* and *rowData* and give it to the function, it will keep existing columns and add new ones at the end. If you do not want to lose any cells after quality metrics check, select *alreadyCellFiltered = TRUE*, by default it is *FALSE*. Before *scran* and *scater* normalization the function will call *scran::quickCluster*, if you want to skip this step, type *runQuickCluster = FALSE*, by default it is *TRUE*. We recommend to use *runQuickCluster = TRUE* for medium-size datasets with 500-10000 cells. However, it can take significant time for a larger amount of cells and will not be useful for small sets of 200-300 samples. 

```{r}
# 1. Normalisation
sceObject <- normaliseCountMatrix(countMatrix, species = "mmu", 
                                  method = "default",
                                  colData = colData)
```
*NormaliseCountMatrix* returns an *sceObject* with slots *counts*, *exprs*, *colData*, *rowData* which can be accessed by *counts(sceObject)* for raw UMI counts, *exprs(sceObject)* for normalized counts etc. Now we can have a look at these four tables. Please notice that *rowData* has columns *go_id* and *name_1006*. However, it keeps information only about two GO terms: "cell_surface" and "surface receptor signaling pathway" (the last one is displayed if the gene is involved in both). This information can help to find surface protein-coding marker genes suitable for FACS easily.

```{r}
# checking what changed after the normalisation
dim(sceObject)
coldataSCE <- as.data.frame(colData(sceObject))
rowdataSCE <- as.data.frame(rowData(sceObject))
counts(sceObject)[1:5,1:5]
exprs(sceObject)[1:5,1:5]
head(coldataSCE)
head(rowdataSCE)
```

The same as with cell barcodes, working with ENSEMBL IDs is not always convenient because they are long and hard to remember. Hence, we prefer to replace the ENSEMBL IDs with Gene SYMBOLs wherever it is possible. For some genes, there were no SYMBOLs in the org.Mm.eg.db database. Therefore we keep the ENSEMBL ID.

```{r}
# substituting ENSEMBL IDs with SYMBOLs for well-annotated genes
rownames(sceObject)[!is.na(rowData(sceObject)$SYMBOL)] = 
    rowData(sceObject)$SYMBOL[!is.na(rowData(sceObject)$SYMBOL)]
```

This dataset was generated using the Takara ICELL8 platform. With this platform, ambient RNA from highly expressed genes such as hemoglobin genes are stabilized by RNase inhibitors and could be a source of contamination. At the exception of sc-RNA-seq protocols involving flow-cytometry based single-cell sorting (Scialdone A et al. 2016 PMID: 27383781), this problem is typical for most sc-RNA-seq platforms such as Drop-Seq and 10X genomics Chromium: see method sections of Ibarra-Soria X, et al. 2018 (PMID: 29311656) and Vento-Tormo R et al. 2018 (PMID: 30429548). We noticed that in this dataset embryonic hemoglobins were detected almost everywhere at a very high level suggesting contamination by ambient RNA. That is why we have included a step to remove them. That said we advise to not remove any genes upon first analysis of a single-cell RNA seq dataset.

```{r}
# deleting hemoblobin genes (recommended only hor hematopoietic systems
# where these genes usually are detected at a very high level)
sceObject <- sceObject[!grepl("Hba", rownames(sceObject)) &
                           !grepl("Hbb", rownames(sceObject)),]
dim(sceObject)
```

## Test clustering
*TestClustering* function runs one clustering round out of the 84 (default) rounds which the *runCONCLUS* function does. This step is not critical for the final result and can be skipped. However, it can be useful to determine if the selected parameters are suitable for your dataset. By default they are dbscanEpsilon = 1.4, minPts = 5, perplexities = c(30), PCs = c(4), randomSeed = 42 and we will use them in the vignette. If the dashed horizontal line in the k-NN distance plot lays on the "knee" of the curve (as shown below), it means that optimal epsilon is equal to the intersection of the line to the y-axis. In our example, optimal epsilon is 1.4 for 5-NN distance where 5 corresponds to *MinPts*. However, the knee is wide so epsilon from 1.2 to 1.8 can be used. We will talk about *runCONCLUS* parameters in detail in Section 4.4.

*TestClustering* creates folders *output_tables*, *pictures*, *marker_genes*, *tsnes*, and *test_clustering* in your *dataDirectory*. In the last one it saves three plots. The first displayed one below corresponds to the "distance_graph.pdf", *p[[1]]* is "test_tSNE.pdf", and *p[[3]]* will be saved as "test_clustering.pdf".

```{r fig.height=5, fig.width=6}
# 2. Test step (optional)
p <- testClustering(sceObject, dataDirectory, experimentName)
```
```{r fig.height=5, fig.width=6}
# saved as "test_clustering/test_tSNE.pdf"
p[[1]]
# saved as "test_custering/test_clustering.pdf"
p[[3]]
```

## runCONCLUS step by step
### Generate t-SNE coordinates
In this section, we will go through the steps of the wrapper function *runCONCLUS*. Firstly, it will create needed output folders if you did not run *testClustering* beforehand. Then it will generate an object of fourteen (by default) tables with tSNE coordinates. Fourteen because it will vary seven values of principal components *PCs=c(4, 6, 8, 10, 20, 40, 50)*, two values of perplexity *perplexities=c(30, 40)*, and random seed 42 in all possible combinations. One can change these parameters if necessary.

```{r}
initialisePath(dataDirectory)
# default parameters, can be selected by a user
PCs=c(4, 6, 8, 10, 20, 40, 50)
perplexities=c(30, 40)
randomSeed = 42
tSNEResults <- generateTSNECoordinates(sceObject, dataDirectory, 
                                          experimentName, PCs=PCs, 
                                          perplexities=perplexities,
                                          randomSeed = randomSeed)
```

```{r}
ncol(tSNEResults)
# the third matrix of t-SNE coordinates with PC = 8 and perplixities = 30
# it is saved as "tsnes/Bergiers_tsne_coordinates_3_8PCs_30perp.tsv"
head(tSNEResults[1,3][[1]])
```

### Mix CONCLUS with your clustering solution
*RunCONCLUS* can run built-in clustering or skip this step if you want to integrate your favorite clustering method. In this case, we assume that you already have a clustering solution which you can add as a column "clusters" to the *colData* of the *sceObject* like in this toy example:

```{r}
colData(sceObject)$clusters = factor(c(rep(1, 100), rep(2, 200), rep(3, 243)))
table(colData(sceObject)$clusters)
```

Regardless of setting the option *preClustered = TRUE or FALSE*, next function will be runDBSCAN. *MinPoints* and *epsilon* are options of the *fpc::dbscan* function where *minPoints* is the minimum cluster size which you assume to be meaningful for your experiment and *epsilon* is the radius around the cell where the algorithm will try to find *minPoints* dots. *Cores* correspond to the number of jobs, which will be run in parallel; by default, it is 14, which is equal to the number of t-SNEs. Optimal *epsilon* must lay one the knee of the k-NN function as shown in the "test_clustering/distance_graph.pdf" (Section 4.3).

```{r}
epsilon=c(1.3, 1.4, 1.5)
minPoints=c(3, 4)
cores=14
message("Running dbscan using ", cores, " cores.")
dbscanResults <- runDBSCAN(tSNEResults, sceObject, dataDirectory, 
                           experimentName, epsilon=epsilon, 
                           minPoints=minPoints,
                           cores=cores)
```

```{r}
dim(dbscanResults)
dbscanResults[1:7, 1:10]
```

### Get cells similarity matrix
*RunDBSCAN* function returns a matrix where columns are cells and rows are 84 clustering solutions (which is equal to number of PCs x perplexities x MinPoints x epsilon, 7 x 2 x 2 x 3 = 84 by default). For example, the cell c10 was assigned to cluster 3 in the "result.1" and to the cluster 2 in the "result.3". Since the range of cluster varies from the result to result, there is no exact match between numbers in different rows. Cells having the same number within a row are guaranteed to be in one cluster. We can calculate how many times out of 84 clustering solutions, every two cells were in one cluster and that is how we come to the similarity matrix of cells. We want to underline, that zero in the *dbscanResults* means that a cell was not assigned to any cluster, so two cells with zeros were not necessarily similar, that is why we count clusters starting from one. *clusterCells* is a general function which returns a *sceObject* with new clusters and calculated *cellsSimilarityMatrix*. In this case, we are already happy with our three clusters, so we take only the second output slot and leave the *sceObject* without any changes of cell filtering after dbscan. 

```{r}
clusteringMethod="ward.D2"
k=10 # parameter for cutree
message("Calculating cells similarity matrix.")
cellsSimilarityMatrix <- clusterCells(dbscanResults, sceObject, clusterNumber=k, 
                                  deepSplit=deepSplit, cores=cores,
                                  clusteringMethod=clusteringMethod)[[2]]
sceObjectFiltered <- sceObject

print(table(colData(sceObjectFiltered)$clusters, 
              dnn=list("Cells distribuion by clusters")))
```
Now we can check if our toy clustering solution reflects the data.
```{r fig.height=6, fig.width=7}
colorPalette="default"
statePalette="default"
plotPDFcellSim = TRUE
orderClusters = FALSE
clustersNumber <- length(unique(colData(sceObjectFiltered)$clusters))
colorPalette <- choosePalette(colorPalette, clustersNumber)

# Plotting cluster stablility
plotCellSimilarity(sceObjectFiltered, cellsSimilarityMatrix, dataDirectory,
                 experimentName, colorPalette, 
                 orderClusters = orderClusters, 
                 statePalette = statePalette, 
                 clusteringMethod = clusteringMethod,
                 plotPDF = plotPDFcellSim,
                 returnPlot = TRUE)
```

*CellsSimilarityMatrix* is symmetrical and its size proportional of to the number of cells x number of cells. Each vertical or horizontal tiny strip is a cell. Intersection shows the proportion of clustering iterations in which a pair of cells was in one cluster, one if always (red), zero if never (blue). In this picture, we can see mainly two "families" of clusters: i8TFs_plus and others. Inside the first family, there are three clear groups, inside the second family we can see seven (one is tiny) squares, two of which form their "subfamily." We can see that our clustering solution reflected more states than clusters. 

### Receive CONCLUS clustering based on dbscan
In the Section, we will use the built-in clustering method. When we set *preClustered = FALSE* in *runCONCLUS*, Sections 4.4.2 and 4.4.3 will be replaced with one function called *runClustering*:

```{r}
deepSplit = 0 # 0 to avoid cutreeDynamic, 1 to 4 to use it
deleteOutliers = FALSE
epsilon=c(1.3, 1.4, 1.5)
minPoints=c(3, 4)
cores=14
clusteringMethod="ward.D2"
k=10 # split the dendrogram with cutree function into 10 groups
clusteringResults <- runClustering(tSNEResults, sceObject, dataDirectory, 
                                       experimentName,
                                       epsilon=epsilon, minPoints=minPoints, 
                                       k=k, deepSplit=deepSplit,
                                       cores=cores,
                                       clusteringMethod=clusteringMethod,
                                       deleteOutliers = deleteOutliers,
                                       PCs=PCs,
                                       perplexities=perplexities, 
                                       randomSeed = randomSeed)
sceObjectFiltered <- clusteringResults[[1]]
cellsSimilarityMatrix <- clusteringResults[[2]]

print(table(colData(sceObjectFiltered)$clusters, 
              dnn=list("Cells distribuion by clusters")))
```

```{r fig.height=6, fig.width=7}
colorPalette="default"
statePalette="default"
plotPDFcellSim = TRUE
orderClusters = FALSE
clustersNumber <- length(unique(colData(sceObjectFiltered)$clusters))
colorPalette <- choosePalette(colorPalette, clustersNumber)

# Plotting cluster stablility
plotCellSimilarity(sceObjectFiltered, cellsSimilarityMatrix, dataDirectory,
                 experimentName, colorPalette, 
                 orderClusters = orderClusters, 
                 statePalette = statePalette, 
                 clusteringMethod = clusteringMethod,
                 plotPDF = plotPDFcellSim,
                 returnPlot = TRUE)
```

This function embodied our intuitive separation of cells into groups. We will call this combination consensus clusters and use it everywhere later. We can appreciate that *cellsSimilarityMatrix* is the first evidence showing that CONCLUS managed not only to distinguish treated cells from controls but also find subpopulations within these groups which were impossible using PCA alone. Next step would be to see the topology of the clusters in our t-SNE plots with tuned parameters. After that, we can have a look at how many genes drive this cluster separation using a heatmap with top markers.

### Plot t-SNE colored by clusters or conditions

```{r}
tSNEclusters <- plotClusteredTSNE(sceObjectFiltered, dataDirectory, experimentName,
                    PCs=PCs, perplexities=perplexities, colorPalette,
                    columnName = "clusters", returnPlot = TRUE)
tSNEnoColor <- plotClusteredTSNE(sceObjectFiltered, dataDirectory, experimentName,
                PCs=PCs, perplexities=perplexities, colorPalette,
                columnName = "noColor", returnPlot = TRUE)
if(any(colnames(colData(sceObjectFiltered)) %in% "state")){
  tSNEstate <- plotClusteredTSNE(sceObjectFiltered, dataDirectory, experimentName,
                    PCs=PCs, perplexities=perplexities, statePalette,
                    columnName = "state", returnPlot = TRUE)
}
```

```{r}
tSNEclusters[[5]]
tSNEnoColor[[5]]
tSNEstate[[5]]
```

### Calculate cluster similarity matrix

In the section 4.4.4., we looked at the similarity between elements on the single-cell level. That approach is useful if we want to understand if there is any substructure which we did not highlight with our clustering. However, this can also be done at a "bulk" level where we pool all cells from a cluster into a representative "pseudo cell." It gives us a *clusterSimilarityMatrix*.
```{r fig.height=5.3, fig.width=6.5}
clustersSimilarityMatrix <- 
      calculateClustersSimilarity(cellsSimilarityMatrix, 
          sceObject = sceObjectFiltered,
          clusteringMethod = "ward.D2")[[1]]
  
plotClustersSimilarity(clustersSimilarityMatrix, 
                       sceObjectFiltered,
                       dataDirectory = dataDirectory, 
                       experimentName = experimentName, 
                       colorPalette = colorPalette,
                       statePalette = statePalette,
                       clusteringMethod = clusteringMethod,
                       returnPlot = TRUE)
```
In the *clusterSimilarityMatrix*, we can still see two major families of clusters. However, now we clearly say that the group "5" does not belong to any of them. It was hard to notice in the *cellsSimilarityMatrix* because that cluster contained few cells and was too small. By the color of the diagonal elements, we can judge how "solid" clusters are. For example, the group "1" is dark-red in the diagonal which means that we do not expect to find differentially expressed (DE) genes inside a group, when clusters "5" or "7" are middle-red which can mean that inside those groups there are few cells which do not belong to them. Yellow color on the diagonal could mean that either that group consists of two or more equal size subgroups or it is a cluster of dbscan "outliers" which usually surround dense clouds of cells in t-SNE plots. Outliers can be removed by an option *deleteOutliers = TRUE* in *runClustering* and *runCONCLUS*. By default, it is *FALSE* because, firstly, calculations take less time and, secondly, sometimes a little part of those outliers could be a "rare" cell type and we would see it in the heatmap with markers.

### Rank genes
The function *rankGenes* takes all genes from the *sceObjectFiltered* and rank them (in our case number of cells is the same as in the *sceObject* because we chose *deleteOutliers = FALSE*). It saves one file for a cluster in the folder *marker_genes*. Inside the record, there is a table where the first column is a gene name in the same annotation as it was in the *sceObjectFiltered*. Then there are *numberOfClusters - 1* columns of adjusted p-values (FDR) of one-tailed T-test between cluster in the name of the file and group in the title of the column. For example, we read the data for the cluster 5 "Bergiers_cluster_5_genes.tsv", the FDR of the hypothesis if a gene was **upregulated** in the cluster 5 versus cluster 1 and is stored in the column "vs_1". **Top genes** with significant FDR in most of the comparisons can be assumed as **positive markers** of a cluster. The column *mean_log10_fdr* is the mean power of FDR in all comparisons; *n_05* is the number of comparisons in which the gene was significantly upregulated. The *score* for marker genes is the average power of FDR among all comparisons for a cluster multiplied to weights taken from the *clustersSimilarityMatrix + 0.05*. Taking account of both FDRs of all comparisons and *clustersSimilarityMatrix* allows keeping the balance between highlighting markers for individual clusters and their "families" which makes the final heatmap as informative as possible. Adding a little number *0.05* to the *clustersSimilarityMatrix* in calculating the score helps to avoid the following problem: in case you have a cluster very different from all others, it will have one on the diagonal and 0 similarities to all others groups in the *clustersSimilarityMatrix*. So all weights for that cluster will be zeros meaning the score would also be zero and genes will be ordered in alphabetical order in the corresponding marker genes list file.

For a cluster $k$ and a gene $G$,  a $score_G$ was defined in the following way:

$$
score_G = \frac{\sum_{i}(-log_{10}(fdr_{k,i} + \epsilon) * weight_{k,i})}{nClusters - 1},
$$

where

1. $fdr_{k,i}$ is an adjusted p-value obtained by comparing expression of $G$ in cluster $k$ versus expression of $G$ in cluster i; 

2. $weight_{k,i}$ is a similarity between these two groups taken from the $<k, i>$ element in the *clustersSimilarityMatrix*; 

3. $nClusters$ is a number of consensus clusters given to the *rankGenes()*;

4. $\epsilon=10^{-300}$ is a small number which does not influence the ranking and added to avoid an error when fdr is equal to zero;

5. $k = [1, ..., nClusters]$; 

6. $i=([1,...,nClusters] \: except \: for \: [k])$

```{r}
rankGenes(sceObjectFiltered, clustersSimilarityMatrix, dataDirectory, 
            experimentName)
rankedGenesClus5 <- read.delim(file.path(dataDirectory, "marker_genes",
                               "Bergiers_cluster_5_genes.tsv"),
                               stringsAsFactors = FALSE)
head(rankedGenesClus5, n = 10)
```
### Export key matrices 
The last part of the *runCONCLUS* function is saving *cellsSimilarityMatrix* and *clustersSimilarityMatrix* in the folder *output_tables* and  returning *sceObjectFiltered*.
```{r}
exportMatrix(cellsSimilarityMatrix, dataDirectory, experimentName, 
           "cellsSimilarityMatrix")
exportMatrix(clustersSimilarityMatrix, dataDirectory, experimentName, 
           "clustersSimilarityMatrix")
```

## runCONCLUS in one function
We have made a great journey with you diving into the details of the CONCLUS workflow. It was important for understanding the tool and getting the maximum from it. However, in everyday practice, we rarely need to run every of functions from the Section 4.4 separately. That is why we combined them into a wrapper *runCONCLUS*. We invite you to continue your code after *testClustering* function.

In the vignette, *runCONCLUS* saves *cellsSimilarityMatrix* and *clustersSimilarityMatrix*, and runs *rankGenes* even if it does not show messages from these steps. 
```{r}
# Reminder where we stopped.
# 2. Test step (optional)
#testClustering(sceObject, dataDirectory, experimentName)

# 3. Running the analysis and saving the consensus clustering solution
sceObjectCONCLUS <- runCONCLUS(sceObject, dataDirectory, experimentName, 
                               plotPDFcellSim = TRUE, # FALSE for > 2500 cells
                               k = 10,
                               cores = 14, # 14 for servers, 1 for PC
                               statePalette = c("bisque", "cadetblue2", 
                                                "coral1", "cornflowerblue"),
                               deleteOutliers = FALSE  # TRUE takes more time
                               )
exportClusteringResults(sceObjectCONCLUS, dataDirectory, experimentName, 
                        "clusters_table.tsv")
```

## Plot a heatmap with positive marker genes

In this section, we visualize top 10 marker genes for each of ten clusters. Theoretically, they must be 100 genes (10 groups x 10 markers), but some could appear twice, so in this particular heatmap, we will see 93 unique genes. Now we ask the function *plotCellHeatmap* to order clusters and genes by similarity (the same order as in the *clusterSimilarityMatrix*) and show mean-centered normalized data. This representation allows seeing the relative expression of a gene compared to the mean. Majority of genes usually has a low or medium number of counts but there are also highly detected genes which will be on the top-red spectrum of the color palette, and it will be impossible to distinguish the difference between cells even if there is the two-fold difference in gene expression. You will see in the next heatmap with normalized expression data that seven and nine look very similar.

```{r}
# 4. Plotting heatmaps
genesNumber <- 10
markersClusters <- getMarkerGenes(dataDirectory, sceObjectCONCLUS, 
                                  experimentName = experimentName,
                                  genesNumber = genesNumber)
orderClusters <- T # F will apply hierarchical clustering to all cells
orderGenes <- T    # F will apply hierarchical clustering to all genes
meanCentered <- T  # F to show normalized counts
plotCellHeatmap(markersClusters, sceObjectCONCLUS, dataDirectory, 
                experimentName, 
                paste0("clusters",
                       length(levels(colData(sceObjectCONCLUS)$clusters)),
                       "_meanCentered",meanCentered,
                       "_orderClusters",orderClusters,
                       "_orderGenes",orderGenes,"_top",
                       genesNumber, "markersPerCluster"), 
                meanCentered = meanCentered, 
                colorPalette = brewer.pal(10, "Paired"),
                orderClusters = orderClusters,
                orderGenes = orderGenes,
                fontsize_row = 4,
                statePalette = c("bisque", "cadetblue2", 
                                 "coral1", "cornflowerblue"),
                color = colorRampPalette(c("#023b84","#4b97fc", 
                                           "#FEE395", 
                                           "#F4794E", "#D73027",
                                           "#a31008","#7a0f09"))(100),
                returnPlot = TRUE)
```

The second heatmap shows also shows the order of genes and clusters by similarity but for normalized expression data.
```{r}
orderClusters <- T # F will apply hierarchical clustering to all cells
orderGenes <- T    # F will apply hierarchical clustering to all genes
meanCentered <- F  # F to show normalized counts
plotCellHeatmap(markersClusters, sceObjectCONCLUS, dataDirectory, 
                experimentName, 
                paste0("clusters",
                       length(levels(colData(sceObjectCONCLUS)$clusters)),
                       "_meanCentered",meanCentered,
                       "_orderClusters",orderClusters,
                       "_orderGenes",orderGenes,"_top",
                       genesNumber, "markersPerCluster"), 
                meanCentered = meanCentered, 
                colorPalette = brewer.pal(10, "Paired"),
                orderClusters = orderClusters,
                orderGenes = orderGenes,
                fontsize_row = 4,
                statePalette = c("bisque", "cadetblue2", 
                                 "coral1", "cornflowerblue"),
                color = colorRampPalette(c("#023b84","#4b97fc", 
                                           "#FEE395", 
                                           "#F4794E", "#D73027",
                                           "#a31008","#7a0f09"))(100),
                returnPlot = TRUE)
```

Alternative order of clusters is by name or by hierarchical clustering as in the default pheatmap function.

## Find markers for your clustering
Imaging you looked through all these 93 genes and decided the cell types of each of clusters. For your publication, you would probably like rename your groups from "1", "2", "3" to "myeloid," "erythroid," "endothelial" cells. You can easily redo all pictures with new cluster names using the *addClusteringManually* function. Since clusters "9" and "10" do not have many evident DE genes, we can merge them and look if the marker selection improves when we consider them as one group.

Following the *runCONCLUS* step, we can export the “Bergiers_clusters_table.tsv” file and rename the group “10” as the group “9”, and overwrite the file.

```{r}
clustersTable <- read.delim(file.path(dataDirectory, "output_tables",                                                    paste0(experimentName, "_clusters_table.tsv")), 
                            stringsAsFactors = FALSE)
clustersTable$clusters[clustersTable$clusters == "10"] = "9"
write.table(clustersTable, file.path(dataDirectory, "output_tables",                                                    paste0(experimentName, "_clusters_table.tsv")), 
            quote = FALSE, sep = "\t")
```

Now we use *runCONCLUS* again to overwrite old marker genes and save new heatmaps. If you want to keep an old folder with marker genes, please rename it, so *runCONCLUS* will create a new *marker_genes* folder.
```{r}
# 5. Correcting clustering manually (optional)
sceObjectCONCLUS <- addClusteringManually(fileName = "clusters_table.tsv", 
    dataDirectory = dataDirectory, 
    experimentName = experimentName,
    sceObject = sceObjectCONCLUS, 
    columnName = "clusters")

# 5.1 Redo the analysis with manual clustering (optional)
sceObjectCONCLUS <- runCONCLUS(sceObjectCONCLUS, dataDirectory, experimentName, 
                        preClustered = T,
                        cores = 14, # 14 for servers, 1 for PC
                        statePalette = c("bisque", "cadetblue2", 
                                         "coral1", "cornflowerblue"))
```

```{r}
genesNumber <- 10
markersClusters <- getMarkerGenes(dataDirectory, sceObjectCONCLUS, 
                                  experimentName = experimentName,
                                  genesNumber = genesNumber)
orderClusters <- T # F will apply hierarchical clustering to all cells
orderGenes <- T    # F will apply hierarchical clustering to all genes
meanCentered <- T  # F to show normalized counts
plotCellHeatmap(markersClusters, sceObjectCONCLUS, dataDirectory, 
                experimentName, 
                paste0("clusters",
                       length(levels(colData(sceObjectCONCLUS)$clusters)),
                       "_meanCentered",meanCentered,
                       "_orderClusters",orderClusters,
                       "_orderGenes",orderGenes,"_top",
                       genesNumber, "markersPerCluster"), 
                meanCentered = meanCentered, 
                colorPalette = brewer.pal(10, "Paired"),
                orderClusters = orderClusters,
                orderGenes = orderGenes,
                fontsize_row = 4,
                statePalette = c("bisque", "cadetblue2", 
                                 "coral1", "cornflowerblue"),
                color = colorRampPalette(c("#023b84","#4b97fc", 
                                           "#FEE395", 
                                           "#F4794E", "#D73027",
                                           "#a31008", "#921912"))(100),
                returnPlot = TRUE)
```

## Plot t-SNE colored by expression of a selected gene

*PlotGeneExpression* allows visualizing normalized expression of one gene in a t-SNE plot. It can be useful to check to inspect specificity of top markers.
```{r}
# 6. Plot gene expression in a selected tSNE plot
plotGeneExpression("Ccl3", experimentName, dataDirectory, sceObjectCONCLUS,
                   tSNEpicture = 10, returnPlot = TRUE)
plotGeneExpression("ENSMUSG00000085700", experimentName, dataDirectory, sceObjectCONCLUS,
                   tSNEpicture = 10, returnPlot = TRUE)
tSNEstate[[10]]
```

## Get genes info
*GetGenesInfo* is a universal function for gene information retrieval from open-source databases and websites of NCBI, MGI, and UniProt by web-scraping. It requires *markersClusters* data frame where the first column "geneName" is mandatory and the second column "clusters" is optional. It can have more than two columns; they will be kept in the output file. *GetGenesInfo* can recognize Gene Symbols and Ensembl IDs, genes from both annotations can be present simultaneously. One can use them for significant DE genes between conditions in bulk RNA-seq data, for example after DESeq2 results.

The second argument must be "databaseDir" which is a path on your computer to the "Mmus_gene_database_secretedMol.tsv" database. For example, we put it to the *dataDirectory*. You can it download from the CONCLUS folder on GitHub.
```{r}
# 7. getGenesInfo example
databaseDir <- dataDirectory
result <- getGenesInfo(markersClusters, databaseDir, groupBy = "clusters")

# 7.1 save the result
outputDir <- file.path(dataDirectory, "/marker_genes/getGenesInfo")
dir.create(outputDir, showWarnings=F)
write.table(result, file = file.path(outputDir, 
                                     "Bergiers_markersClusters_top10_clusters9_genesInfo.csv"),
            quote = FALSE, sep = ";", row.names = FALSE)
```

## Save genes info
*MarkersClusters* usually contains 10-20 top marker genes per clusters when it is more reliable to use 100 genes for cell state annotation. The function *saveMarkersLists* will create data frames with top 100 (by default) top marker genes for each cluster. The second column will be the name of the group. It will create "marker_genes/markers_lists" folder and save them there. The *saveGenesInfo* function will save results of *getGenesInfo* into outputDir which we specify. It goes file by file sequentially. If you see an error that the connection the website took to much time and dropped, restart the *saveGenesInfo* from the table where it failed using the *startFromFile* option. We will specify "startFromFile = 9" to calculate the output only for the last cluster. Hence, we reduce the computational time and the number of output messages. For your analysis, we recommend selecting "startFromFile = 1".

```{r}
# 8. saveGenesInfo example
saveMarkersLists(experimentName, dataDirectory)
```

```{r}
inputDir <- file.path(dataDirectory, "/marker_genes/markers_lists")
pattern <- "markers.csv"
outputDir <- file.path(dataDirectory, "/marker_genes/saveGenesInfo")
databaseDir <- dataDirectory

dir.create(outputDir, showWarnings=F)

saveGenesInfo(inputDir, pattern, outputDir, databaseDir, 
              sep = ";", header = TRUE, startFromFile = 9)
```

## Save workspace
*ExportData* function saves the working space into *output_tables/Bergiers_full_workspace.RData*. Additionally, it saves *output_tables/Bergiers_exression_matrix.tsv*, with normalized counts, *output_tables/Bergiers_colData.tsv*, and *output_tables/Bergiers_rowData.tsv*.
```{r}
# 9. Export data (optional)
exportData(sceObjectCONCLUS, dataDirectory, experimentName)
```

# Session info

```{r}
sessionInfo()
```

